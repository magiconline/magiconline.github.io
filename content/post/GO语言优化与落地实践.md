---
title: "Go语言优化与落地实践"
date: 2022-05-13T15:50:28+08:00
draft: false
---

# 自动内存管理
由程序语言的运行时系统回收动态内存
- 避免手动内存管理，专注于实现业务逻辑
- 保证内存使用的正确性和安全性
  
三个任务
- 为新对象分配内存
- 找到存活对象
- 回收死亡对象的内存空间

相关概念
- Mutator: 业务线程, 分配新对象, 修改对象指向关系
- Collector: GC 线程，找到存活对象, 回收死亡对象
- Serial GC: 只有一个collector
- Parallel GC: 支持多个collectors同时回收
- Concurrent GC: mutator和collector可以同时执行
    - collector必须感知对象指向关系的改变
## 追踪垃圾回收
- 对象被回收的条件: 指针指向关系不可达的对象
- 标记根对象
    - 静态变量，全局变量，常量，线程等
- 标记: 找到可达对象
    - 求指针指向关系的传递闭包，从根对象触发，找到所有可达对象
- 清理所有不可达的对象
    - 将存活对象复制到另外空间(Copying GC)
    - 将死亡对象的内存标记为可分配(Mask-sweep GC)
    - 移动并整理存活对象(Mask-compack GC)
- 根据对象的生命周期，使用不同的标记和清理策略

## 分代GC
- 分代假说：大多数对象生命周期很短
- 针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销
- 不同年龄的对象处于heap的不同区域
- 年轻代
    - 常规的对象分配，存活对象少，可以用copying GC
    - GC吞吐率高
- 老年代
    - 对象趋向于一直或者，反复复制开销大
    - 可以用 mask-sweep GC

## 引用计数
- 每个对象都有一个与之关联的引用计数
- 对象存活的条件：当且仅当引用计数大于0
- 优点
    - 内存管理的操作平摊到程序执行过程中
    - 内存管理不需要了解runtime的实现细节(c++智能指针)
- 缺点
    - 维护引用计数的开销大，通过原子操作保证对引用计数的操作
    - 无法回收环形数据结构
    - 内存开销：每个对象都引入的额外内存空间存储引用数目
    - 回收内存时依然可能引发暂停
  
# Go内存管理及优化
## 内存分配-分块
- 目的：为对象在heap上分配内存
- 提前将内存分块
    - 调用系统调用mmap()向OS申请一大块内存，例如4MB
    - 先将内存分成大块，如8KB，称作mspan
    - 再将大块继续划分成特定大小的块，用于对象分配
    - noscan mspan：分配不包含指针的对象，GC 不需要扫描
    - scan mspan：分配包含指针的对象，GC 需要扫描
- 对象分配：根据对象的大小，选择最合适的块
  
## 内存分配-缓存
- 每个p包含mcache用于快速分配
- mcache管理一组mspan
- 当mcache中的mspan分配完毕，向mcentral申请新mspan
- 当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS

## 内存管理优化
- 对象分配是非常高频的操作
- 小对象占比比较高
- Go内存分配比较耗时

## 优化方案：Balanced GC
- 每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB)
- GAB用于noscan类型的小对象分配: < 128B
- 用三个指针维护GAB: base, end, top
- 分配对象只需要移动top指针
- GAB对于mspan来说是一个大对象
- 本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放
- 方案：移动GAB中存活的对象(copying GC)
# 编译器和静态分析

# Go编译器优化
