---
title: "Go语言优化与落地实践"
date: 2022-05-13T15:50:28+08:00
draft: false
---

# 自动内存管理
由程序语言的运行时系统回收动态内存
- 避免手动内存管理，专注于实现业务逻辑
- 保证内存使用的正确性和安全性
  
三个任务
- 为新对象分配内存
- 找到存活对象
- 回收死亡对象的内存空间

相关概念
- Mutator: 业务线程, 分配新对象, 修改对象指向关系
- Collector: GC 线程，找到存活对象, 回收死亡对象
- Serial GC: 只有一个collector
- Parallel GC: 支持多个collectors同时回收
- Concurrent GC: mutator和collector可以同时执行
    - collector必须感知对象指向关系的改变
## 追踪垃圾回收
- 对象被回收的条件: 指针指向关系不可达的对象
- 标记根对象
    - 静态变量，全局变量，常量，线程等
- 标记: 找到可达对象
    - 求指针指向关系的传递闭包，从根对象触发，找到所有可达对象
- 清理所有不可达的对象
    - 将存活对象复制到另外空间(Copying GC)
    - 将死亡对象的内存标记为可分配(Mask-sweep GC)
    - 移动并整理存活对象(Mask-compack GC)
- 根据对象的生命周期，使用不同的标记和清理策略

## 分代GC
- 分代假说：大多数对象生命周期很短
- 针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销
- 不同年龄的对象处于heap的不同区域
- 年轻代
    - 常规的对象分配，存活对象少，可以用copying GC
    - GC吞吐率高
- 老年代
    - 对象趋向于一直或者，反复复制开销大
    - 可以用 mask-sweep GC

## 引用计数
- 每个对象都有一个与之关联的引用计数
- 对象存活的条件：当且仅当引用计数大于0
- 优点
    - 内存管理的操作平摊到程序执行过程中
    - 内存管理不需要了解runtime的实现细节(c++智能指针)
- 缺点
    - 维护引用计数的开销大，通过原子操作保证对引用计数的操作
    - 无法回收环形数据结构
    - 内存开销：每个对象都引入的额外内存空间存储引用数目
    - 回收内存时依然可能引发暂停
  
# Go内存管理及优化
## 内存分配-分块
- 目的：为对象在heap上分配内存
- 提前将内存分块
    - 调用系统调用mmap()向OS申请一大块内存，例如4MB
    - 先将内存分成大块，如8KB，称作mspan
    - 再将大块继续划分成特定大小的块，用于对象分配
    - noscan mspan：分配不包含指针的对象，GC 不需要扫描
    - scan mspan：分配包含指针的对象，GC 需要扫描
- 对象分配：根据对象的大小，选择最合适的块
  
## 内存分配-缓存
- 每个p包含mcache用于快速分配
- mcache管理一组mspan
- 当mcache中的mspan分配完毕，向mcentral申请新mspan
- 当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS

## 内存管理优化
- 对象分配是非常高频的操作
- 小对象占比比较高
- Go内存分配比较耗时

## 优化方案：Balanced GC
- 每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB)
- GAB用于noscan类型的小对象分配: < 128B
- 用三个指针维护GAB: base, end, top
- 分配对象只需要移动top指针
- GAB对于mspan来说是一个大对象
- 本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放
- 方案：移动GAB中存活的对象(copying GC)
# 编译器和静态分析
## 编译器的结构
- 前端
  - 词法分析 -> 词素
  - 语法分期 -> 抽象语法树
  - 语义分析 -> 抽象语法树
  - 中间表示 -> IR
- 后端
  - 代码优化 -> IR
  - 代码生成 -> 目标代码

## 静态分析
- 静态分析：不执行程序代码，推导程序的行为，分析程序的性质
- 控制流：程序执行的流程
- 数据流：数据在控制流上的流程

## 过程内分析和过程间分析
- 过程分析
  - 尽在函数内部进行分析
- 过程间分析
  - 考虑函数调用时参数传递和返回值的数据流和控制流
- 过程间分析需要同时分析控制流和数据流

# Go编译器优化
- 为什么做编译器优化
    - 用户无感知，重新编译即可获得性能收益
    - 通用性优化
- 现状
  - 采用的优化少
  - 编译时间较短，没有进行较复杂的代码分析和优化
- 编译优化的思路
  - 场景：面向后端长期执行的任务
  - Tradeoff：用编译时间换区更高效的机器码
- Beast mode
  - 函数内联
  - 逃逸分析
  - 默认栈大小调整
  - 边界检查消除
  - 循环展开
  - ......

## 函数内联
- 内联：将函数的函数体的副本替换到调用位置上，然后重写代码以反映参数的绑定
- 优点
  - 消除函数调用开销
  - 将过程间分析转换为过程内分析，帮助优化，例如逃逸分析
- 缺点
  - 函数体变大，对 cpu cache 不友好
  - 生成的代码变大
- 函数内联在大多数情况下是正向优化
- 内联策略：调用和被调用函数的规模

## Beast Mode
- interface，defer等限制了函数内联

## 逃逸分析
- 逃逸分析：分析代码中指针的动态作用域：指针在何处可以被访问
- 大致思路
  - 从对象分配处出发，沿着控制流，观察对象的数据流
  - 若发现指针p在当前作用域s：
    - 作为参数传递给其它函数
    - 传递给全局变量
    - 传递给其它goroutine
    - 传递给已逃逸的指针指针的对象
  - 则zhizhenp只想的对象逃逸出s，反之则没有逃逸出s
- Beast mode：函数内联拓展了函数边界，更多对象不逃逸
- 优化：未逃逸的对象可以在栈上分配
  - 对象在栈上分配和回收很快：移动sp
  - 减少在heap上的分配，降低GC负担