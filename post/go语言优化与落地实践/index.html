<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Go语言优化与落地实践 - 魔法张的Blog</title><meta name=description content="自动内存管理 由程序语言的运行时系统回收动态内存
 避免手动内存管理，专注于实现业务逻辑 保证内存使用的正确性和安全性  三个任务
 为新对象分配内存 找到存活对象 回收死亡对象的内存空间  相关概念
 Mutator: 业务线程, 分配新对象, 修改对象指向关系 Collector: GC 线程，找到存活对象, 回收死亡对象 Serial GC: 只有一个collector Parallel GC: 支持多个collectors同时回收 Concurrent GC: mutator和collector可以同时执行  collector必须感知对象指向关系的改变    追踪垃圾回收  对象被回收的条件: 指针指向关系不可达的对象 标记根对象  静态变量，全局变量，常量，线程等   标记: 找到可达对象  求指针指向关系的传递闭包，从根对象触发，找到所有可达对象   清理所有不可达的对象  将存活对象复制到另外空间(Copying GC) 将死亡对象的内存标记为可分配(Mask-sweep GC) 移动并整理存活对象(Mask-compack GC)   根据对象的生命周期，使用不同的标记和清理策略  分代GC  分代假说：大多数对象生命周期很短 针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销 不同年龄的对象处于heap的不同区域 年轻代  常规的对象分配，存活对象少，可以用copying GC GC吞吐率高   老年代  对象趋向于一直或者，反复复制开销大 可以用 mask-sweep GC    引用计数  每个对象都有一个与之关联的引用计数 对象存活的条件：当且仅当引用计数大于0 优点  内存管理的操作平摊到程序执行过程中 内存管理不需要了解runtime的实现细节(c++智能指针)   缺点  维护引用计数的开销大，通过原子操作保证对引用计数的操作 无法回收环形数据结构 内存开销：每个对象都引入的额外内存空间存储引用数目 回收内存时依然可能引发暂停    Go内存管理及优化 内存分配-分块  目的：为对象在heap上分配内存 提前将内存分块  调用系统调用mmap()向OS申请一大块内存，例如4MB 先将内存分成大块，如8KB，称作mspan 再将大块继续划分成特定大小的块，用于对象分配 noscan mspan：分配不包含指针的对象，GC 不需要扫描 scan mspan：分配包含指针的对象，GC 需要扫描   对象分配：根据对象的大小，选择最合适的块  内存分配-缓存  每个p包含mcache用于快速分配 mcache管理一组mspan 当mcache中的mspan分配完毕，向mcentral申请新mspan 当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS  内存管理优化  对象分配是非常高频的操作 小对象占比比较高 Go内存分配比较耗时  优化方案：Balanced GC  每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB) GAB用于noscan类型的小对象分配: < 128B 用三个指针维护GAB: base, end, top 分配对象只需要移动top指针 GAB对于mspan来说是一个大对象 本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放 方案：移动GAB中存活的对象(copying GC)  编译器和静态分析 编译器的结构  前端  词法分析 -> 词素 语法分期 -> 抽象语法树 语义分析 -> 抽象语法树 中间表示 -> IR   后端  代码优化 -> IR 代码生成 -> 目标代码    静态分析  静态分析：不执行程序代码，推导程序的行为，分析程序的性质 控制流：程序执行的流程 数据流：数据在控制流上的流程  过程内分析和过程间分析  过程分析  尽在函数内部进行分析   过程间分析  考虑函数调用时参数传递和返回值的数据流和控制流   过程间分析需要同时分析控制流和数据流  Go编译器优化  为什么做编译器优化  用户无感知，重新编译即可获得性能收益 通用性优化   现状  采用的优化少 编译时间较短，没有进行较复杂的代码分析和优化   编译优化的思路  场景：面向后端长期执行的任务 Tradeoff：用编译时间换区更高效的机器码   Beast mode  函数内联 逃逸分析 默认栈大小调整 边界检查消除 循环展开 &mldr;&mldr;    函数内联  内联：将函数的函数体的副本替换到调用位置上，然后重写代码以反映参数的绑定 优点  消除函数调用开销 将过程间分析转换为过程内分析，帮助优化，例如逃逸分析   缺点  函数体变大，对 cpu cache 不友好 生成的代码变大   函数内联在大多数情况下是正向优化 内联策略：调用和被调用函数的规模  Beast Mode  interface，defer等限制了函数内联  逃逸分析  逃逸分析：分析代码中指针的动态作用域：指针在何处可以被访问 大致思路  从对象分配处出发，沿着控制流，观察对象的数据流 若发现指针p在当前作用域s：  作为参数传递给其它函数 传递给全局变量 传递给其它goroutine 传递给已逃逸的指针指针的对象   则zhizhenp只想的对象逃逸出s，反之则没有逃逸出s   Beast mode：函数内联拓展了函数边界，更多对象不逃逸 优化：未逃逸的对象可以在栈上分配  对象在栈上分配和回收很快：移动sp 减少在heap上的分配，降低GC负担    "><meta name=author content><link rel="preload stylesheet" as=style href=https://magiconline.github.io/app.min.css><link rel="preload stylesheet" as=style href=https://magiconline.github.io/an-old-hope.min.css><script defer src=https://magiconline.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=https://magiconline.github.io/theme.png><link rel=preload as=image href=https://magiconline.github.io/github.svg><link rel=icon href=https://magiconline.github.io/favicon.ico><link rel=apple-touch-icon href=https://magiconline.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.99.1"><meta property="og:title" content="Go语言优化与落地实践"><meta property="og:description" content="自动内存管理 由程序语言的运行时系统回收动态内存
 避免手动内存管理，专注于实现业务逻辑 保证内存使用的正确性和安全性  三个任务
 为新对象分配内存 找到存活对象 回收死亡对象的内存空间  相关概念
 Mutator: 业务线程, 分配新对象, 修改对象指向关系 Collector: GC 线程，找到存活对象, 回收死亡对象 Serial GC: 只有一个collector Parallel GC: 支持多个collectors同时回收 Concurrent GC: mutator和collector可以同时执行  collector必须感知对象指向关系的改变    追踪垃圾回收  对象被回收的条件: 指针指向关系不可达的对象 标记根对象  静态变量，全局变量，常量，线程等   标记: 找到可达对象  求指针指向关系的传递闭包，从根对象触发，找到所有可达对象   清理所有不可达的对象  将存活对象复制到另外空间(Copying GC) 将死亡对象的内存标记为可分配(Mask-sweep GC) 移动并整理存活对象(Mask-compack GC)   根据对象的生命周期，使用不同的标记和清理策略  分代GC  分代假说：大多数对象生命周期很短 针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销 不同年龄的对象处于heap的不同区域 年轻代  常规的对象分配，存活对象少，可以用copying GC GC吞吐率高   老年代  对象趋向于一直或者，反复复制开销大 可以用 mask-sweep GC    引用计数  每个对象都有一个与之关联的引用计数 对象存活的条件：当且仅当引用计数大于0 优点  内存管理的操作平摊到程序执行过程中 内存管理不需要了解runtime的实现细节(c++智能指针)   缺点  维护引用计数的开销大，通过原子操作保证对引用计数的操作 无法回收环形数据结构 内存开销：每个对象都引入的额外内存空间存储引用数目 回收内存时依然可能引发暂停    Go内存管理及优化 内存分配-分块  目的：为对象在heap上分配内存 提前将内存分块  调用系统调用mmap()向OS申请一大块内存，例如4MB 先将内存分成大块，如8KB，称作mspan 再将大块继续划分成特定大小的块，用于对象分配 noscan mspan：分配不包含指针的对象，GC 不需要扫描 scan mspan：分配包含指针的对象，GC 需要扫描   对象分配：根据对象的大小，选择最合适的块  内存分配-缓存  每个p包含mcache用于快速分配 mcache管理一组mspan 当mcache中的mspan分配完毕，向mcentral申请新mspan 当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS  内存管理优化  对象分配是非常高频的操作 小对象占比比较高 Go内存分配比较耗时  优化方案：Balanced GC  每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB) GAB用于noscan类型的小对象分配: < 128B 用三个指针维护GAB: base, end, top 分配对象只需要移动top指针 GAB对于mspan来说是一个大对象 本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放 方案：移动GAB中存活的对象(copying GC)  编译器和静态分析 编译器的结构  前端  词法分析 -> 词素 语法分期 -> 抽象语法树 语义分析 -> 抽象语法树 中间表示 -> IR   后端  代码优化 -> IR 代码生成 -> 目标代码    静态分析  静态分析：不执行程序代码，推导程序的行为，分析程序的性质 控制流：程序执行的流程 数据流：数据在控制流上的流程  过程内分析和过程间分析  过程分析  尽在函数内部进行分析   过程间分析  考虑函数调用时参数传递和返回值的数据流和控制流   过程间分析需要同时分析控制流和数据流  Go编译器优化  为什么做编译器优化  用户无感知，重新编译即可获得性能收益 通用性优化   现状  采用的优化少 编译时间较短，没有进行较复杂的代码分析和优化   编译优化的思路  场景：面向后端长期执行的任务 Tradeoff：用编译时间换区更高效的机器码   Beast mode  函数内联 逃逸分析 默认栈大小调整 边界检查消除 循环展开 &mldr;&mldr;    函数内联  内联：将函数的函数体的副本替换到调用位置上，然后重写代码以反映参数的绑定 优点  消除函数调用开销 将过程间分析转换为过程内分析，帮助优化，例如逃逸分析   缺点  函数体变大，对 cpu cache 不友好 生成的代码变大   函数内联在大多数情况下是正向优化 内联策略：调用和被调用函数的规模  Beast Mode  interface，defer等限制了函数内联  逃逸分析  逃逸分析：分析代码中指针的动态作用域：指针在何处可以被访问 大致思路  从对象分配处出发，沿着控制流，观察对象的数据流 若发现指针p在当前作用域s：  作为参数传递给其它函数 传递给全局变量 传递给其它goroutine 传递给已逃逸的指针指针的对象   则zhizhenp只想的对象逃逸出s，反之则没有逃逸出s   Beast mode：函数内联拓展了函数边界，更多对象不逃逸 优化：未逃逸的对象可以在栈上分配  对象在栈上分配和回收很快：移动sp 减少在heap上的分配，降低GC负担    "><meta property="og:type" content="article"><meta property="og:url" content="https://magiconline.github.io/post/go%E8%AF%AD%E8%A8%80%E4%BC%98%E5%8C%96%E4%B8%8E%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-13T15:50:28+08:00"><meta property="article:modified_time" content="2022-05-13T15:50:28+08:00"><meta itemprop=name content="Go语言优化与落地实践"><meta itemprop=description content="自动内存管理 由程序语言的运行时系统回收动态内存
 避免手动内存管理，专注于实现业务逻辑 保证内存使用的正确性和安全性  三个任务
 为新对象分配内存 找到存活对象 回收死亡对象的内存空间  相关概念
 Mutator: 业务线程, 分配新对象, 修改对象指向关系 Collector: GC 线程，找到存活对象, 回收死亡对象 Serial GC: 只有一个collector Parallel GC: 支持多个collectors同时回收 Concurrent GC: mutator和collector可以同时执行  collector必须感知对象指向关系的改变    追踪垃圾回收  对象被回收的条件: 指针指向关系不可达的对象 标记根对象  静态变量，全局变量，常量，线程等   标记: 找到可达对象  求指针指向关系的传递闭包，从根对象触发，找到所有可达对象   清理所有不可达的对象  将存活对象复制到另外空间(Copying GC) 将死亡对象的内存标记为可分配(Mask-sweep GC) 移动并整理存活对象(Mask-compack GC)   根据对象的生命周期，使用不同的标记和清理策略  分代GC  分代假说：大多数对象生命周期很短 针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销 不同年龄的对象处于heap的不同区域 年轻代  常规的对象分配，存活对象少，可以用copying GC GC吞吐率高   老年代  对象趋向于一直或者，反复复制开销大 可以用 mask-sweep GC    引用计数  每个对象都有一个与之关联的引用计数 对象存活的条件：当且仅当引用计数大于0 优点  内存管理的操作平摊到程序执行过程中 内存管理不需要了解runtime的实现细节(c++智能指针)   缺点  维护引用计数的开销大，通过原子操作保证对引用计数的操作 无法回收环形数据结构 内存开销：每个对象都引入的额外内存空间存储引用数目 回收内存时依然可能引发暂停    Go内存管理及优化 内存分配-分块  目的：为对象在heap上分配内存 提前将内存分块  调用系统调用mmap()向OS申请一大块内存，例如4MB 先将内存分成大块，如8KB，称作mspan 再将大块继续划分成特定大小的块，用于对象分配 noscan mspan：分配不包含指针的对象，GC 不需要扫描 scan mspan：分配包含指针的对象，GC 需要扫描   对象分配：根据对象的大小，选择最合适的块  内存分配-缓存  每个p包含mcache用于快速分配 mcache管理一组mspan 当mcache中的mspan分配完毕，向mcentral申请新mspan 当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS  内存管理优化  对象分配是非常高频的操作 小对象占比比较高 Go内存分配比较耗时  优化方案：Balanced GC  每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB) GAB用于noscan类型的小对象分配: < 128B 用三个指针维护GAB: base, end, top 分配对象只需要移动top指针 GAB对于mspan来说是一个大对象 本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放 方案：移动GAB中存活的对象(copying GC)  编译器和静态分析 编译器的结构  前端  词法分析 -> 词素 语法分期 -> 抽象语法树 语义分析 -> 抽象语法树 中间表示 -> IR   后端  代码优化 -> IR 代码生成 -> 目标代码    静态分析  静态分析：不执行程序代码，推导程序的行为，分析程序的性质 控制流：程序执行的流程 数据流：数据在控制流上的流程  过程内分析和过程间分析  过程分析  尽在函数内部进行分析   过程间分析  考虑函数调用时参数传递和返回值的数据流和控制流   过程间分析需要同时分析控制流和数据流  Go编译器优化  为什么做编译器优化  用户无感知，重新编译即可获得性能收益 通用性优化   现状  采用的优化少 编译时间较短，没有进行较复杂的代码分析和优化   编译优化的思路  场景：面向后端长期执行的任务 Tradeoff：用编译时间换区更高效的机器码   Beast mode  函数内联 逃逸分析 默认栈大小调整 边界检查消除 循环展开 &mldr;&mldr;    函数内联  内联：将函数的函数体的副本替换到调用位置上，然后重写代码以反映参数的绑定 优点  消除函数调用开销 将过程间分析转换为过程内分析，帮助优化，例如逃逸分析   缺点  函数体变大，对 cpu cache 不友好 生成的代码变大   函数内联在大多数情况下是正向优化 内联策略：调用和被调用函数的规模  Beast Mode  interface，defer等限制了函数内联  逃逸分析  逃逸分析：分析代码中指针的动态作用域：指针在何处可以被访问 大致思路  从对象分配处出发，沿着控制流，观察对象的数据流 若发现指针p在当前作用域s：  作为参数传递给其它函数 传递给全局变量 传递给其它goroutine 传递给已逃逸的指针指针的对象   则zhizhenp只想的对象逃逸出s，反之则没有逃逸出s   Beast mode：函数内联拓展了函数边界，更多对象不逃逸 优化：未逃逸的对象可以在栈上分配  对象在栈上分配和回收很快：移动sp 减少在heap上的分配，降低GC负担    "><meta itemprop=datePublished content="2022-05-13T15:50:28+08:00"><meta itemprop=dateModified content="2022-05-13T15:50:28+08:00"><meta itemprop=wordCount content="189"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Go语言优化与落地实践"><meta name=twitter:description content="自动内存管理 由程序语言的运行时系统回收动态内存
 避免手动内存管理，专注于实现业务逻辑 保证内存使用的正确性和安全性  三个任务
 为新对象分配内存 找到存活对象 回收死亡对象的内存空间  相关概念
 Mutator: 业务线程, 分配新对象, 修改对象指向关系 Collector: GC 线程，找到存活对象, 回收死亡对象 Serial GC: 只有一个collector Parallel GC: 支持多个collectors同时回收 Concurrent GC: mutator和collector可以同时执行  collector必须感知对象指向关系的改变    追踪垃圾回收  对象被回收的条件: 指针指向关系不可达的对象 标记根对象  静态变量，全局变量，常量，线程等   标记: 找到可达对象  求指针指向关系的传递闭包，从根对象触发，找到所有可达对象   清理所有不可达的对象  将存活对象复制到另外空间(Copying GC) 将死亡对象的内存标记为可分配(Mask-sweep GC) 移动并整理存活对象(Mask-compack GC)   根据对象的生命周期，使用不同的标记和清理策略  分代GC  分代假说：大多数对象生命周期很短 针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销 不同年龄的对象处于heap的不同区域 年轻代  常规的对象分配，存活对象少，可以用copying GC GC吞吐率高   老年代  对象趋向于一直或者，反复复制开销大 可以用 mask-sweep GC    引用计数  每个对象都有一个与之关联的引用计数 对象存活的条件：当且仅当引用计数大于0 优点  内存管理的操作平摊到程序执行过程中 内存管理不需要了解runtime的实现细节(c++智能指针)   缺点  维护引用计数的开销大，通过原子操作保证对引用计数的操作 无法回收环形数据结构 内存开销：每个对象都引入的额外内存空间存储引用数目 回收内存时依然可能引发暂停    Go内存管理及优化 内存分配-分块  目的：为对象在heap上分配内存 提前将内存分块  调用系统调用mmap()向OS申请一大块内存，例如4MB 先将内存分成大块，如8KB，称作mspan 再将大块继续划分成特定大小的块，用于对象分配 noscan mspan：分配不包含指针的对象，GC 不需要扫描 scan mspan：分配包含指针的对象，GC 需要扫描   对象分配：根据对象的大小，选择最合适的块  内存分配-缓存  每个p包含mcache用于快速分配 mcache管理一组mspan 当mcache中的mspan分配完毕，向mcentral申请新mspan 当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS  内存管理优化  对象分配是非常高频的操作 小对象占比比较高 Go内存分配比较耗时  优化方案：Balanced GC  每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB) GAB用于noscan类型的小对象分配: < 128B 用三个指针维护GAB: base, end, top 分配对象只需要移动top指针 GAB对于mspan来说是一个大对象 本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放 方案：移动GAB中存活的对象(copying GC)  编译器和静态分析 编译器的结构  前端  词法分析 -> 词素 语法分期 -> 抽象语法树 语义分析 -> 抽象语法树 中间表示 -> IR   后端  代码优化 -> IR 代码生成 -> 目标代码    静态分析  静态分析：不执行程序代码，推导程序的行为，分析程序的性质 控制流：程序执行的流程 数据流：数据在控制流上的流程  过程内分析和过程间分析  过程分析  尽在函数内部进行分析   过程间分析  考虑函数调用时参数传递和返回值的数据流和控制流   过程间分析需要同时分析控制流和数据流  Go编译器优化  为什么做编译器优化  用户无感知，重新编译即可获得性能收益 通用性优化   现状  采用的优化少 编译时间较短，没有进行较复杂的代码分析和优化   编译优化的思路  场景：面向后端长期执行的任务 Tradeoff：用编译时间换区更高效的机器码   Beast mode  函数内联 逃逸分析 默认栈大小调整 边界检查消除 循环展开 &mldr;&mldr;    函数内联  内联：将函数的函数体的副本替换到调用位置上，然后重写代码以反映参数的绑定 优点  消除函数调用开销 将过程间分析转换为过程内分析，帮助优化，例如逃逸分析   缺点  函数体变大，对 cpu cache 不友好 生成的代码变大   函数内联在大多数情况下是正向优化 内联策略：调用和被调用函数的规模  Beast Mode  interface，defer等限制了函数内联  逃逸分析  逃逸分析：分析代码中指针的动态作用域：指针在何处可以被访问 大致思路  从对象分配处出发，沿着控制流，观察对象的数据流 若发现指针p在当前作用域s：  作为参数传递给其它函数 传递给全局变量 传递给其它goroutine 传递给已逃逸的指针指针的对象   则zhizhenp只想的对象逃逸出s，反之则没有逃逸出s   Beast mode：函数内联拓展了函数边界，更多对象不逃逸 优化：未逃逸的对象可以在栈上分配  对象在栈上分配和回收很快：移动sp 减少在heap上的分配，降低GC负担    "></head><body class=not-ready data-menu=true><header class=header><p class=logo><a class=site-name href=https://magiconline.github.io/>魔法张的Blog</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>{bodyClx[e?"add":"remove"]("dark"),localStorage.setItem("dark",e?"yes":"no")};setDark(darkVal?darkVal==="yes":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",e=>setDark(e.matches))</script><nav class=menu><a href=/about/>About</a></nav><nav class=social><a class=github style=--url:url(./github.svg) href=https://github.com/magiconline target=_blank></a></nav></header><main class=main><article class=post-single><header class=post-title><p><time>May 13, 2022</time></p><h1>Go语言优化与落地实践</h1></header><section class=post-content><h1 id=自动内存管理>自动内存管理</h1><p>由程序语言的运行时系统回收动态内存</p><ul><li>避免手动内存管理，专注于实现业务逻辑</li><li>保证内存使用的正确性和安全性</li></ul><p>三个任务</p><ul><li>为新对象分配内存</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul><p>相关概念</p><ul><li>Mutator: 业务线程, 分配新对象, 修改对象指向关系</li><li>Collector: GC 线程，找到存活对象, 回收死亡对象</li><li>Serial GC: 只有一个collector</li><li>Parallel GC: 支持多个collectors同时回收</li><li>Concurrent GC: mutator和collector可以同时执行<ul><li>collector必须感知对象指向关系的改变</li></ul></li></ul><h2 id=追踪垃圾回收>追踪垃圾回收</h2><ul><li>对象被回收的条件: 指针指向关系不可达的对象</li><li>标记根对象<ul><li>静态变量，全局变量，常量，线程等</li></ul></li><li>标记: 找到可达对象<ul><li>求指针指向关系的传递闭包，从根对象触发，找到所有可达对象</li></ul></li><li>清理所有不可达的对象<ul><li>将存活对象复制到另外空间(Copying GC)</li><li>将死亡对象的内存标记为可分配(Mask-sweep GC)</li><li>移动并整理存活对象(Mask-compack GC)</li></ul></li><li>根据对象的生命周期，使用不同的标记和清理策略</li></ul><h2 id=分代gc>分代GC</h2><ul><li>分代假说：大多数对象生命周期很短</li><li>针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销</li><li>不同年龄的对象处于heap的不同区域</li><li>年轻代<ul><li>常规的对象分配，存活对象少，可以用copying GC</li><li>GC吞吐率高</li></ul></li><li>老年代<ul><li>对象趋向于一直或者，反复复制开销大</li><li>可以用 mask-sweep GC</li></ul></li></ul><h2 id=引用计数>引用计数</h2><ul><li>每个对象都有一个与之关联的引用计数</li><li>对象存活的条件：当且仅当引用计数大于0</li><li>优点<ul><li>内存管理的操作平摊到程序执行过程中</li><li>内存管理不需要了解runtime的实现细节(c++智能指针)</li></ul></li><li>缺点<ul><li>维护引用计数的开销大，通过原子操作保证对引用计数的操作</li><li>无法回收环形数据结构</li><li>内存开销：每个对象都引入的额外内存空间存储引用数目</li><li>回收内存时依然可能引发暂停</li></ul></li></ul><h1 id=go内存管理及优化>Go内存管理及优化</h1><h2 id=内存分配-分块>内存分配-分块</h2><ul><li>目的：为对象在heap上分配内存</li><li>提前将内存分块<ul><li>调用系统调用mmap()向OS申请一大块内存，例如4MB</li><li>先将内存分成大块，如8KB，称作mspan</li><li>再将大块继续划分成特定大小的块，用于对象分配</li><li>noscan mspan：分配不包含指针的对象，GC 不需要扫描</li><li>scan mspan：分配包含指针的对象，GC 需要扫描</li></ul></li><li>对象分配：根据对象的大小，选择最合适的块</li></ul><h2 id=内存分配-缓存>内存分配-缓存</h2><ul><li>每个p包含mcache用于快速分配</li><li>mcache管理一组mspan</li><li>当mcache中的mspan分配完毕，向mcentral申请新mspan</li><li>当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS</li></ul><h2 id=内存管理优化>内存管理优化</h2><ul><li>对象分配是非常高频的操作</li><li>小对象占比比较高</li><li>Go内存分配比较耗时</li></ul><h2 id=优化方案balanced-gc>优化方案：Balanced GC</h2><ul><li>每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB)</li><li>GAB用于noscan类型的小对象分配: &lt; 128B</li><li>用三个指针维护GAB: base, end, top</li><li>分配对象只需要移动top指针</li><li>GAB对于mspan来说是一个大对象</li><li>本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放</li><li>方案：移动GAB中存活的对象(copying GC)</li></ul><h1 id=编译器和静态分析>编译器和静态分析</h1><h2 id=编译器的结构>编译器的结构</h2><ul><li>前端<ul><li>词法分析 -> 词素</li><li>语法分期 -> 抽象语法树</li><li>语义分析 -> 抽象语法树</li><li>中间表示 -> IR</li></ul></li><li>后端<ul><li>代码优化 -> IR</li><li>代码生成 -> 目标代码</li></ul></li></ul><h2 id=静态分析>静态分析</h2><ul><li>静态分析：不执行程序代码，推导程序的行为，分析程序的性质</li><li>控制流：程序执行的流程</li><li>数据流：数据在控制流上的流程</li></ul><h2 id=过程内分析和过程间分析>过程内分析和过程间分析</h2><ul><li>过程分析<ul><li>尽在函数内部进行分析</li></ul></li><li>过程间分析<ul><li>考虑函数调用时参数传递和返回值的数据流和控制流</li></ul></li><li>过程间分析需要同时分析控制流和数据流</li></ul><h1 id=go编译器优化>Go编译器优化</h1><ul><li>为什么做编译器优化<ul><li>用户无感知，重新编译即可获得性能收益</li><li>通用性优化</li></ul></li><li>现状<ul><li>采用的优化少</li><li>编译时间较短，没有进行较复杂的代码分析和优化</li></ul></li><li>编译优化的思路<ul><li>场景：面向后端长期执行的任务</li><li>Tradeoff：用编译时间换区更高效的机器码</li></ul></li><li>Beast mode<ul><li>函数内联</li><li>逃逸分析</li><li>默认栈大小调整</li><li>边界检查消除</li><li>循环展开</li><li>&mldr;&mldr;</li></ul></li></ul><h2 id=函数内联>函数内联</h2><ul><li>内联：将函数的函数体的副本替换到调用位置上，然后重写代码以反映参数的绑定</li><li>优点<ul><li>消除函数调用开销</li><li>将过程间分析转换为过程内分析，帮助优化，例如逃逸分析</li></ul></li><li>缺点<ul><li>函数体变大，对 cpu cache 不友好</li><li>生成的代码变大</li></ul></li><li>函数内联在大多数情况下是正向优化</li><li>内联策略：调用和被调用函数的规模</li></ul><h2 id=beast-mode>Beast Mode</h2><ul><li>interface，defer等限制了函数内联</li></ul><h2 id=逃逸分析>逃逸分析</h2><ul><li>逃逸分析：分析代码中指针的动态作用域：指针在何处可以被访问</li><li>大致思路<ul><li>从对象分配处出发，沿着控制流，观察对象的数据流</li><li>若发现指针p在当前作用域s：<ul><li>作为参数传递给其它函数</li><li>传递给全局变量</li><li>传递给其它goroutine</li><li>传递给已逃逸的指针指针的对象</li></ul></li><li>则zhizhenp只想的对象逃逸出s，反之则没有逃逸出s</li></ul></li><li>Beast mode：函数内联拓展了函数边界，更多对象不逃逸</li><li>优化：未逃逸的对象可以在栈上分配<ul><li>对象在栈上分配和回收很快：移动sp</li><li>减少在heap上的分配，降低GC负担</li></ul></li></ul></section><nav class=post-nav><a class=prev href=https://magiconline.github.io/post/gorm%E5%AE%9E%E8%B7%B5/><span>←</span><span>GORM实践</span></a>
<a class=next href=https://magiconline.github.io/post/go-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/><span>Go性能优化建议</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2022 <a href=https://magiconline.github.io/>魔法张的Blog</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>