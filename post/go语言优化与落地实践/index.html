<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Go语言优化与落地实践 - 魔法张的Blog</title><meta name=description content="自动内存管理 由程序语言的运行时系统回收动态内存
 避免手动内存管理，专注于实现业务逻辑 保证内存使用的正确性和安全性  三个任务
 为新对象分配内存 找到存活对象 回收死亡对象的内存空间  相关概念
 Mutator: 业务线程, 分配新对象, 修改对象指向关系 Collector: GC 线程，找到存活对象, 回收死亡对象 Serial GC: 只有一个collector Parallel GC: 支持多个collectors同时回收 Concurrent GC: mutator和collector可以同时执行  collector必须感知对象指向关系的改变    追踪垃圾回收  对象被回收的条件: 指针指向关系不可达的对象 标记根对象  静态变量，全局变量，常量，线程等   标记: 找到可达对象  求指针指向关系的传递闭包，从根对象触发，找到所有可达对象   清理所有不可达的对象  将存活对象复制到另外空间(Copying GC) 将死亡对象的内存标记为可分配(Mask-sweep GC) 移动并整理存活对象(Mask-compack GC)   根据对象的生命周期，使用不同的标记和清理策略  分代GC  分代假说：大多数对象生命周期很短 针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销 不同年龄的对象处于heap的不同区域 年轻代  常规的对象分配，存活对象少，可以用copying GC GC吞吐率高   老年代  对象趋向于一直或者，反复复制开销大 可以用 mask-sweep GC    引用计数  每个对象都有一个与之关联的引用计数 对象存活的条件：当且仅当引用计数大于0 优点  内存管理的操作平摊到程序执行过程中 内存管理不需要了解runtime的实现细节(c++智能指针)   缺点  维护引用计数的开销大，通过原子操作保证对引用计数的操作 无法回收环形数据结构 内存开销：每个对象都引入的额外内存空间存储引用数目 回收内存时依然可能引发暂停    Go内存管理及优化 内存分配-分块  目的：为对象在heap上分配内存 提前将内存分块  调用系统调用mmap()向OS申请一大块内存，例如4MB 先将内存分成大块，如8KB，称作mspan 再将大块继续划分成特定大小的块，用于对象分配 noscan mspan：分配不包含指针的对象，GC 不需要扫描 scan mspan：分配包含指针的对象，GC 需要扫描   对象分配：根据对象的大小，选择最合适的块  内存分配-缓存  每个p包含mcache用于快速分配 mcache管理一组mspan 当mcache中的mspan分配完毕，向mcentral申请新mspan 当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS  内存管理优化  对象分配是非常高频的操作 小对象占比比较高 Go内存分配比较耗时  优化方案：Balanced GC  每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB) GAB用于noscan类型的小对象分配: < 128B 用三个指针维护GAB: base, end, top 分配对象只需要移动top指针 GAB对于mspan来说是一个大对象 本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放 方案：移动GAB中存活的对象(copying GC)  编译器和静态分析 Go编译器优化 "><meta name=author content><link rel="preload stylesheet" as=style href=https://magiconline.github.io/app.min.css><link rel="preload stylesheet" as=style href=https://magiconline.github.io/an-old-hope.min.css><script defer src=https://magiconline.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=https://magiconline.github.io/theme.png><link rel=preload as=image href=https://magiconline.github.io/github.svg><link rel=icon href=https://magiconline.github.io/favicon.ico><link rel=apple-touch-icon href=https://magiconline.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.99.1"><meta property="og:title" content="Go语言优化与落地实践"><meta property="og:description" content="自动内存管理 由程序语言的运行时系统回收动态内存
 避免手动内存管理，专注于实现业务逻辑 保证内存使用的正确性和安全性  三个任务
 为新对象分配内存 找到存活对象 回收死亡对象的内存空间  相关概念
 Mutator: 业务线程, 分配新对象, 修改对象指向关系 Collector: GC 线程，找到存活对象, 回收死亡对象 Serial GC: 只有一个collector Parallel GC: 支持多个collectors同时回收 Concurrent GC: mutator和collector可以同时执行  collector必须感知对象指向关系的改变    追踪垃圾回收  对象被回收的条件: 指针指向关系不可达的对象 标记根对象  静态变量，全局变量，常量，线程等   标记: 找到可达对象  求指针指向关系的传递闭包，从根对象触发，找到所有可达对象   清理所有不可达的对象  将存活对象复制到另外空间(Copying GC) 将死亡对象的内存标记为可分配(Mask-sweep GC) 移动并整理存活对象(Mask-compack GC)   根据对象的生命周期，使用不同的标记和清理策略  分代GC  分代假说：大多数对象生命周期很短 针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销 不同年龄的对象处于heap的不同区域 年轻代  常规的对象分配，存活对象少，可以用copying GC GC吞吐率高   老年代  对象趋向于一直或者，反复复制开销大 可以用 mask-sweep GC    引用计数  每个对象都有一个与之关联的引用计数 对象存活的条件：当且仅当引用计数大于0 优点  内存管理的操作平摊到程序执行过程中 内存管理不需要了解runtime的实现细节(c++智能指针)   缺点  维护引用计数的开销大，通过原子操作保证对引用计数的操作 无法回收环形数据结构 内存开销：每个对象都引入的额外内存空间存储引用数目 回收内存时依然可能引发暂停    Go内存管理及优化 内存分配-分块  目的：为对象在heap上分配内存 提前将内存分块  调用系统调用mmap()向OS申请一大块内存，例如4MB 先将内存分成大块，如8KB，称作mspan 再将大块继续划分成特定大小的块，用于对象分配 noscan mspan：分配不包含指针的对象，GC 不需要扫描 scan mspan：分配包含指针的对象，GC 需要扫描   对象分配：根据对象的大小，选择最合适的块  内存分配-缓存  每个p包含mcache用于快速分配 mcache管理一组mspan 当mcache中的mspan分配完毕，向mcentral申请新mspan 当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS  内存管理优化  对象分配是非常高频的操作 小对象占比比较高 Go内存分配比较耗时  优化方案：Balanced GC  每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB) GAB用于noscan类型的小对象分配: < 128B 用三个指针维护GAB: base, end, top 分配对象只需要移动top指针 GAB对于mspan来说是一个大对象 本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放 方案：移动GAB中存活的对象(copying GC)  编译器和静态分析 Go编译器优化 "><meta property="og:type" content="article"><meta property="og:url" content="https://magiconline.github.io/post/go%E8%AF%AD%E8%A8%80%E4%BC%98%E5%8C%96%E4%B8%8E%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-13T15:50:28+08:00"><meta property="article:modified_time" content="2022-05-13T15:50:28+08:00"><meta itemprop=name content="Go语言优化与落地实践"><meta itemprop=description content="自动内存管理 由程序语言的运行时系统回收动态内存
 避免手动内存管理，专注于实现业务逻辑 保证内存使用的正确性和安全性  三个任务
 为新对象分配内存 找到存活对象 回收死亡对象的内存空间  相关概念
 Mutator: 业务线程, 分配新对象, 修改对象指向关系 Collector: GC 线程，找到存活对象, 回收死亡对象 Serial GC: 只有一个collector Parallel GC: 支持多个collectors同时回收 Concurrent GC: mutator和collector可以同时执行  collector必须感知对象指向关系的改变    追踪垃圾回收  对象被回收的条件: 指针指向关系不可达的对象 标记根对象  静态变量，全局变量，常量，线程等   标记: 找到可达对象  求指针指向关系的传递闭包，从根对象触发，找到所有可达对象   清理所有不可达的对象  将存活对象复制到另外空间(Copying GC) 将死亡对象的内存标记为可分配(Mask-sweep GC) 移动并整理存活对象(Mask-compack GC)   根据对象的生命周期，使用不同的标记和清理策略  分代GC  分代假说：大多数对象生命周期很短 针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销 不同年龄的对象处于heap的不同区域 年轻代  常规的对象分配，存活对象少，可以用copying GC GC吞吐率高   老年代  对象趋向于一直或者，反复复制开销大 可以用 mask-sweep GC    引用计数  每个对象都有一个与之关联的引用计数 对象存活的条件：当且仅当引用计数大于0 优点  内存管理的操作平摊到程序执行过程中 内存管理不需要了解runtime的实现细节(c++智能指针)   缺点  维护引用计数的开销大，通过原子操作保证对引用计数的操作 无法回收环形数据结构 内存开销：每个对象都引入的额外内存空间存储引用数目 回收内存时依然可能引发暂停    Go内存管理及优化 内存分配-分块  目的：为对象在heap上分配内存 提前将内存分块  调用系统调用mmap()向OS申请一大块内存，例如4MB 先将内存分成大块，如8KB，称作mspan 再将大块继续划分成特定大小的块，用于对象分配 noscan mspan：分配不包含指针的对象，GC 不需要扫描 scan mspan：分配包含指针的对象，GC 需要扫描   对象分配：根据对象的大小，选择最合适的块  内存分配-缓存  每个p包含mcache用于快速分配 mcache管理一组mspan 当mcache中的mspan分配完毕，向mcentral申请新mspan 当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS  内存管理优化  对象分配是非常高频的操作 小对象占比比较高 Go内存分配比较耗时  优化方案：Balanced GC  每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB) GAB用于noscan类型的小对象分配: < 128B 用三个指针维护GAB: base, end, top 分配对象只需要移动top指针 GAB对于mspan来说是一个大对象 本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放 方案：移动GAB中存活的对象(copying GC)  编译器和静态分析 Go编译器优化 "><meta itemprop=datePublished content="2022-05-13T15:50:28+08:00"><meta itemprop=dateModified content="2022-05-13T15:50:28+08:00"><meta itemprop=wordCount content="110"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Go语言优化与落地实践"><meta name=twitter:description content="自动内存管理 由程序语言的运行时系统回收动态内存
 避免手动内存管理，专注于实现业务逻辑 保证内存使用的正确性和安全性  三个任务
 为新对象分配内存 找到存活对象 回收死亡对象的内存空间  相关概念
 Mutator: 业务线程, 分配新对象, 修改对象指向关系 Collector: GC 线程，找到存活对象, 回收死亡对象 Serial GC: 只有一个collector Parallel GC: 支持多个collectors同时回收 Concurrent GC: mutator和collector可以同时执行  collector必须感知对象指向关系的改变    追踪垃圾回收  对象被回收的条件: 指针指向关系不可达的对象 标记根对象  静态变量，全局变量，常量，线程等   标记: 找到可达对象  求指针指向关系的传递闭包，从根对象触发，找到所有可达对象   清理所有不可达的对象  将存活对象复制到另外空间(Copying GC) 将死亡对象的内存标记为可分配(Mask-sweep GC) 移动并整理存活对象(Mask-compack GC)   根据对象的生命周期，使用不同的标记和清理策略  分代GC  分代假说：大多数对象生命周期很短 针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销 不同年龄的对象处于heap的不同区域 年轻代  常规的对象分配，存活对象少，可以用copying GC GC吞吐率高   老年代  对象趋向于一直或者，反复复制开销大 可以用 mask-sweep GC    引用计数  每个对象都有一个与之关联的引用计数 对象存活的条件：当且仅当引用计数大于0 优点  内存管理的操作平摊到程序执行过程中 内存管理不需要了解runtime的实现细节(c++智能指针)   缺点  维护引用计数的开销大，通过原子操作保证对引用计数的操作 无法回收环形数据结构 内存开销：每个对象都引入的额外内存空间存储引用数目 回收内存时依然可能引发暂停    Go内存管理及优化 内存分配-分块  目的：为对象在heap上分配内存 提前将内存分块  调用系统调用mmap()向OS申请一大块内存，例如4MB 先将内存分成大块，如8KB，称作mspan 再将大块继续划分成特定大小的块，用于对象分配 noscan mspan：分配不包含指针的对象，GC 不需要扫描 scan mspan：分配包含指针的对象，GC 需要扫描   对象分配：根据对象的大小，选择最合适的块  内存分配-缓存  每个p包含mcache用于快速分配 mcache管理一组mspan 当mcache中的mspan分配完毕，向mcentral申请新mspan 当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS  内存管理优化  对象分配是非常高频的操作 小对象占比比较高 Go内存分配比较耗时  优化方案：Balanced GC  每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB) GAB用于noscan类型的小对象分配: < 128B 用三个指针维护GAB: base, end, top 分配对象只需要移动top指针 GAB对于mspan来说是一个大对象 本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放 方案：移动GAB中存活的对象(copying GC)  编译器和静态分析 Go编译器优化 "></head><body class=not-ready data-menu=true><header class=header><p class=logo><a class=site-name href=https://magiconline.github.io/>魔法张的Blog</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>{bodyClx[e?"add":"remove"]("dark"),localStorage.setItem("dark",e?"yes":"no")};setDark(darkVal?darkVal==="yes":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",e=>setDark(e.matches))</script><nav class=menu><a href=/about/>About</a></nav><nav class=social><a class=github style=--url:url(./github.svg) href=https://github.com/magiconline target=_blank></a></nav></header><main class=main><article class=post-single><header class=post-title><p><time>May 13, 2022</time></p><h1>Go语言优化与落地实践</h1></header><section class=post-content><h1 id=自动内存管理>自动内存管理</h1><p>由程序语言的运行时系统回收动态内存</p><ul><li>避免手动内存管理，专注于实现业务逻辑</li><li>保证内存使用的正确性和安全性</li></ul><p>三个任务</p><ul><li>为新对象分配内存</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul><p>相关概念</p><ul><li>Mutator: 业务线程, 分配新对象, 修改对象指向关系</li><li>Collector: GC 线程，找到存活对象, 回收死亡对象</li><li>Serial GC: 只有一个collector</li><li>Parallel GC: 支持多个collectors同时回收</li><li>Concurrent GC: mutator和collector可以同时执行<ul><li>collector必须感知对象指向关系的改变</li></ul></li></ul><h2 id=追踪垃圾回收>追踪垃圾回收</h2><ul><li>对象被回收的条件: 指针指向关系不可达的对象</li><li>标记根对象<ul><li>静态变量，全局变量，常量，线程等</li></ul></li><li>标记: 找到可达对象<ul><li>求指针指向关系的传递闭包，从根对象触发，找到所有可达对象</li></ul></li><li>清理所有不可达的对象<ul><li>将存活对象复制到另外空间(Copying GC)</li><li>将死亡对象的内存标记为可分配(Mask-sweep GC)</li><li>移动并整理存活对象(Mask-compack GC)</li></ul></li><li>根据对象的生命周期，使用不同的标记和清理策略</li></ul><h2 id=分代gc>分代GC</h2><ul><li>分代假说：大多数对象生命周期很短</li><li>针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销</li><li>不同年龄的对象处于heap的不同区域</li><li>年轻代<ul><li>常规的对象分配，存活对象少，可以用copying GC</li><li>GC吞吐率高</li></ul></li><li>老年代<ul><li>对象趋向于一直或者，反复复制开销大</li><li>可以用 mask-sweep GC</li></ul></li></ul><h2 id=引用计数>引用计数</h2><ul><li>每个对象都有一个与之关联的引用计数</li><li>对象存活的条件：当且仅当引用计数大于0</li><li>优点<ul><li>内存管理的操作平摊到程序执行过程中</li><li>内存管理不需要了解runtime的实现细节(c++智能指针)</li></ul></li><li>缺点<ul><li>维护引用计数的开销大，通过原子操作保证对引用计数的操作</li><li>无法回收环形数据结构</li><li>内存开销：每个对象都引入的额外内存空间存储引用数目</li><li>回收内存时依然可能引发暂停</li></ul></li></ul><h1 id=go内存管理及优化>Go内存管理及优化</h1><h2 id=内存分配-分块>内存分配-分块</h2><ul><li>目的：为对象在heap上分配内存</li><li>提前将内存分块<ul><li>调用系统调用mmap()向OS申请一大块内存，例如4MB</li><li>先将内存分成大块，如8KB，称作mspan</li><li>再将大块继续划分成特定大小的块，用于对象分配</li><li>noscan mspan：分配不包含指针的对象，GC 不需要扫描</li><li>scan mspan：分配包含指针的对象，GC 需要扫描</li></ul></li><li>对象分配：根据对象的大小，选择最合适的块</li></ul><h2 id=内存分配-缓存>内存分配-缓存</h2><ul><li>每个p包含mcache用于快速分配</li><li>mcache管理一组mspan</li><li>当mcache中的mspan分配完毕，向mcentral申请新mspan</li><li>当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS</li></ul><h2 id=内存管理优化>内存管理优化</h2><ul><li>对象分配是非常高频的操作</li><li>小对象占比比较高</li><li>Go内存分配比较耗时</li></ul><h2 id=优化方案balanced-gc>优化方案：Balanced GC</h2><ul><li>每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB)</li><li>GAB用于noscan类型的小对象分配: &lt; 128B</li><li>用三个指针维护GAB: base, end, top</li><li>分配对象只需要移动top指针</li><li>GAB对于mspan来说是一个大对象</li><li>本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放</li><li>方案：移动GAB中存活的对象(copying GC)</li></ul><h1 id=编译器和静态分析>编译器和静态分析</h1><h1 id=go编译器优化>Go编译器优化</h1></section><nav class=post-nav><a class=prev href=https://magiconline.github.io/post/gorm%E5%AE%9E%E8%B7%B5/><span>←</span><span>GORM实践</span></a>
<a class=next href=https://magiconline.github.io/post/go-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/><span>Go性能优化建议</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2022 <a href=https://magiconline.github.io/>魔法张的Blog</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>