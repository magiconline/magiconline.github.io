<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 魔法张的Blog</title><link>https://magiconline.github.io/post/</link><description>Recent content in Posts on 魔法张的Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 03 Jun 2022 14:13:26 +0800</lastBuildDate><atom:link href="https://magiconline.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>带你认识存储数据库</title><link>https://magiconline.github.io/post/%E5%B8%A6%E4%BD%A0%E8%AE%A4%E8%AF%86%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Fri, 03 Jun 2022 14:13:26 +0800</pubDate><guid>https://magiconline.github.io/post/%E5%B8%A6%E4%BD%A0%E8%AE%A4%E8%AF%86%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>经典案例 数据的持久化 校验数据的合法性 修改内存（用高效的数据结构组织数据） 写入存储介质（以寿命&amp;amp;性能友好的方式写入硬件） 潜在问题 数据库怎么保证数据不丢 数据库怎么处理多人同时修改的问题 为什么用数据库，除了数据库还能存到别的存储系统吗 数据库只能处理结构化数据吗 有哪些操作数据库的方式，要用什么编程语言 存储 &amp;amp; 数据库简介 存储系统 一个提供了读写、控制类接口，能够安全有效地把数据持久化的软件，就可以称为存储系统。
特点：性能敏感、代码简单又复杂、容易受硬件影响。
数据库 关系：任意元素组成的若干有序偶对
SQL：一种DSL，方便人类阅读的关系代数的表达形式
关系型数据库 数据化结构友好、支持事务、支持复杂查询语言SQL。
非关系型数据库 一般不要求严格的结构化。 半结构化数据友好、可能支持事务、可能支持复杂查询语言。
数据库 VS 经典存储 结构化数据关系 关系型数据库以表形式管理。
写入文件，自定义行，管理结构。
事务能力 数据库支持事务：
Atomicity：事务内的操作要么全做，要么不做。 Consistency，事务执行前后，数据状态是一致的。 Isolation，可以隔离多个并发事务，避免影响。 Durability，事务一旦提交成功，数据保证持久性。 复杂查询能力 SQL VS 编程语言
主流产品剖析 单机存储 单机存储：单个计算机节点上的存储软件系统，一般不涉及网络交互。
本地文件系统 文件系统接口：Ext2/3/4，sysfs，rootfs等，都遵循VFS的统一抽象接口。
Index Node: 记录文件元数据，如ID，大小、权限、位置等。inode是一个文件的唯一标识，会被存储到磁盘上，inode的总数在格式化文件系统时就固定了。 Directory Entry: 记录文件名、inode指针、层级关系等。dentry是内存结构，与inode的关系是N:1。
key-value存储 使用方式: put(k, v) &amp;amp; get(k) 常见的数据结构：LSM-Tree 产品：rocksdb
分布式存储 分布式存储：在单机存储基础上实现了分布式协议，涉及大量网络交互。
分布式文件系统 HDFS，Ceph
单机关系型数据库 Oracle、MySQL、PostgreSQL。
通用组件：
Query Engine：解析query，生成查询计划 Txn Manager：负责事务并发管理 Lock Manager：负责锁相关的策略 Storage Engine：负责组织内存、磁盘数据结构 Replication：负责主备同步 关键内存数据结构：B-Tree、B+-Tree、LRU List</description></item><item><title>分布式定时任务</title><link>https://magiconline.github.io/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link><pubDate>Thu, 02 Jun 2022 15:43:33 +0800</pubDate><guid>https://magiconline.github.io/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid><description>前言 春节集卡瓜分20亿技术 自动化 + 定时执行 + 海量数据 + 高效稳定 = 分布式定时任务
发展历程 单机定时任务 10分钟后Windows电脑自动关机 自动疫情打卡 Linux命令 - CronJob 定时清理机器日志 单机定时任务 Ticker(GO)，定时刷新本地缓存 Quartz 单任务极致控制，没有负载均匀任务 分布式定时任务 平台化管理，分布式部署，支持海量数据
分布式定时任务是把分散的、可靠性差的定时任务纳入统一的平台，并实现集群管理调度和分布式部署的一种定时任务的管理方式。
按触发时机分类：
定时任务：15点触发 延时任务：10s后触发 周期任务：每天15点触发，每10s触发 执行方式：
单级任务：随机触发一台机器执行任务。 广播任务：广播到所有机器上执行同一个任务。 Map任务：一个任务可以分出多个子任务，每个子任务负责一部分的计算。 MapReduce任务：在Map任务的基础上，还可以对所有子任务的结果做汇总计算。 定时任务框架 xxl-job
分布式定时任务VS大数据处理引擎：
都可以对海量数据做处理，性能、伸缩性、稳定性都很高。
大数据处理引擎往往致力于将源数据处理成结果数据，分布式定时任务除了能做这个之外，还可以调用HTTP和RPC服务。
以发奖为例：分布式定时任务可以计算哪些用户发奖，然后进行发奖。而大数据处理只能计算哪些用户发奖。
实现原理 核心架构 分布式定时任务核心要解决触发、调度、执行三个关键问题。
触发器：解析任务，生成触发事件。 调度器：分配任务，管理任务生命周期。 执行器：获取执行任务单元，执行任务逻辑。 此外，还需要控制台，提供任务管理和干预的功能。 数据流 控制台 任务：任务元数据 任务实例：任务运行的实例 任务结果：可能任务失败重试产生多个结果 任务历史 任务元数据 包含基础信息、调度时机、执行行为、执行方式。
任务实例 一个确定的Job的一次运行实例。
Job_id 触发时间 状态&amp;amp;结果 过程信息 触发器 核心职责 给定一系列任务，解析他们的触发规则，在规定的时间点触发任务的调度。
设计约束：
需支持大量任务 需支持秒级的任务 周期任务需要多次执行 需保证秒级扫描的高性能，并避免资源浪费 方案1 定时扫描 + 延时消息。</description></item><item><title>GORM实践</title><link>https://magiconline.github.io/post/gorm%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 16 May 2022 14:53:41 +0800</pubDate><guid>https://magiconline.github.io/post/gorm%E5%AE%9E%E8%B7%B5/</guid><description>1 简介 1.1 DB连接的几种类型 直接连接/Conn
预编译/Stmt
事务/Tx
1.2 处理返回数据的几种方法 Result
Rows
Row
2 GORM 2.1 CRUD 操作数据库
// 创建 db.AutoMigrate(&amp;amp;Product{}) db.Migrator().CreateTable(&amp;amp;Product{}) // 插入 db.Create(&amp;amp;user) // 读取 db.First(&amp;amp;product) db.Find(&amp;amp;users, []int{1,2,3}) // 更新 db.Model(&amp;amp;product).Update(&amp;#34;Price&amp;#34;, 200) // 删除 db.Delete(&amp;amp;product) 2.2 Model 定义 2.3 惯例约定 2.4 关联操作 3 GORM 设计原理 3.1 SQL生成 SQL是怎么生成的
SELECT * FROM * WHERE * ORDERBY * LIMIT * FOR * // 必选：SELECT FROM // 可选：WHERE ORDERBY LIMIT db.Where().Where().Limit().Order().Find() // Chain Method + Finisher Method 3.</description></item><item><title>Go语言优化与落地实践</title><link>https://magiconline.github.io/post/go%E8%AF%AD%E8%A8%80%E4%BC%98%E5%8C%96%E4%B8%8E%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/</link><pubDate>Fri, 13 May 2022 15:50:28 +0800</pubDate><guid>https://magiconline.github.io/post/go%E8%AF%AD%E8%A8%80%E4%BC%98%E5%8C%96%E4%B8%8E%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/</guid><description>自动内存管理 由程序语言的运行时系统回收动态内存
避免手动内存管理，专注于实现业务逻辑 保证内存使用的正确性和安全性 三个任务
为新对象分配内存 找到存活对象 回收死亡对象的内存空间 相关概念
Mutator: 业务线程, 分配新对象, 修改对象指向关系 Collector: GC 线程，找到存活对象, 回收死亡对象 Serial GC: 只有一个collector Parallel GC: 支持多个collectors同时回收 Concurrent GC: mutator和collector可以同时执行 collector必须感知对象指向关系的改变 追踪垃圾回收 对象被回收的条件: 指针指向关系不可达的对象 标记根对象 静态变量，全局变量，常量，线程等 标记: 找到可达对象 求指针指向关系的传递闭包，从根对象触发，找到所有可达对象 清理所有不可达的对象 将存活对象复制到另外空间(Copying GC) 将死亡对象的内存标记为可分配(Mask-sweep GC) 移动并整理存活对象(Mask-compack GC) 根据对象的生命周期，使用不同的标记和清理策略 分代GC 分代假说：大多数对象生命周期很短 针对年轻和年老的对象，指定不同的GC策略，降低内存管理的开销 不同年龄的对象处于heap的不同区域 年轻代 常规的对象分配，存活对象少，可以用copying GC GC吞吐率高 老年代 对象趋向于一直或者，反复复制开销大 可以用 mask-sweep GC 引用计数 每个对象都有一个与之关联的引用计数 对象存活的条件：当且仅当引用计数大于0 优点 内存管理的操作平摊到程序执行过程中 内存管理不需要了解runtime的实现细节(c++智能指针) 缺点 维护引用计数的开销大，通过原子操作保证对引用计数的操作 无法回收环形数据结构 内存开销：每个对象都引入的额外内存空间存储引用数目 回收内存时依然可能引发暂停 Go内存管理及优化 内存分配-分块 目的：为对象在heap上分配内存 提前将内存分块 调用系统调用mmap()向OS申请一大块内存，例如4MB 先将内存分成大块，如8KB，称作mspan 再将大块继续划分成特定大小的块，用于对象分配 noscan mspan：分配不包含指针的对象，GC 不需要扫描 scan mspan：分配包含指针的对象，GC 需要扫描 对象分配：根据对象的大小，选择最合适的块 内存分配-缓存 每个p包含mcache用于快速分配 mcache管理一组mspan 当mcache中的mspan分配完毕，向mcentral申请新mspan 当mspan没有分配的对象，mspan会被缓存在mcentral中，而不是归还给OS 内存管理优化 对象分配是非常高频的操作 小对象占比比较高 Go内存分配比较耗时 优化方案：Balanced GC 每个g 绑定一块大内存(1KB)，称作goroutine allocation buffer(GAB) GAB用于noscan类型的小对象分配: &amp;lt; 128B 用三个指针维护GAB: base, end, top 分配对象只需要移动top指针 GAB对于mspan来说是一个大对象 本质是将多个小对象的分配合并成一次大对象的分配，但会导致GAB内存的延迟释放 方案：移动GAB中存活的对象(copying GC) 编译器和静态分析 编译器的结构 前端 词法分析 -&amp;gt; 词素 语法分期 -&amp;gt; 抽象语法树 语义分析 -&amp;gt; 抽象语法树 中间表示 -&amp;gt; IR 后端 代码优化 -&amp;gt; IR 代码生成 -&amp;gt; 目标代码 静态分析 静态分析：不执行程序代码，推导程序的行为，分析程序的性质 控制流：程序执行的流程 数据流：数据在控制流上的流程 过程内分析和过程间分析 过程分析 尽在函数内部进行分析 过程间分析 考虑函数调用时参数传递和返回值的数据流和控制流 过程间分析需要同时分析控制流和数据流 Go编译器优化 为什么做编译器优化 用户无感知，重新编译即可获得性能收益 通用性优化 现状 采用的优化少 编译时间较短，没有进行较复杂的代码分析和优化 编译优化的思路 场景：面向后端长期执行的任务 Tradeoff：用编译时间换区更高效的机器码 Beast mode 函数内联 逃逸分析 默认栈大小调整 边界检查消除 循环展开 &amp;hellip;&amp;hellip; 函数内联 内联：将函数的函数体的副本替换到调用位置上，然后重写代码以反映参数的绑定 优点 消除函数调用开销 将过程间分析转换为过程内分析，帮助优化，例如逃逸分析 缺点 函数体变大，对 cpu cache 不友好 生成的代码变大 函数内联在大多数情况下是正向优化 内联策略：调用和被调用函数的规模 Beast Mode interface，defer等限制了函数内联 逃逸分析 逃逸分析：分析代码中指针的动态作用域：指针在何处可以被访问 大致思路 从对象分配处出发，沿着控制流，观察对象的数据流 若发现指针p在当前作用域s： 作为参数传递给其它函数 传递给全局变量 传递给其它goroutine 传递给已逃逸的指针指针的对象 则zhizhenp只想的对象逃逸出s，反之则没有逃逸出s Beast mode：函数内联拓展了函数边界，更多对象不逃逸 优化：未逃逸的对象可以在栈上分配 对象在栈上分配和回收很快：移动sp 减少在heap上的分配，降低GC负担</description></item><item><title>Go性能优化建议</title><link>https://magiconline.github.io/post/go-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</link><pubDate>Wed, 11 May 2022 20:55:03 +0800</pubDate><guid>https://magiconline.github.io/post/go-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</guid><description>高性能编程 时间性能优化 Slice 尽量预分配内存，减少append操作扩容的频率。 Slice扩容时会复制原数组到新数组。 可使用 go test --bench=. --benchmem 查看内存分配次数、分配容量。
Slice切片时不会新建数组，而是引用已有的数组。 可能导致一个小Slice切片自一个大Slice时，大Slice的内存不会被释放，可使用copy替代[:]操作。
map 与Slice相同，可通过提前分配内存，减少内存拷贝和Rehash的消耗。
字符串 字符串是不可变类型，使用的内存是固定的，每次用+都会重新分配内存。 使用strings.Builder拼接大量字符串，底层是[]bytes数组，不会每次都重新分配内存。 bytes.Buffer最后会重新创建一个新的字符串，因此稍慢。
还可以使用builder.Grow(n)提前分配内存，减少申请内存次数。
空间性能优化 使用空结构体节省内存 空结构体不占据任何内存空间，可作为各种场景下的占位符。
应用场景：map[int]struct{}，通过map实现了set。
多线程 线程安全 使用atomic包性能会比Mutex性能高。 因为Mutex通过操作系统实现，atomic操作通过硬件实现。
Mutex用来保护一段逻辑，atomic用来保护一个变量。
性能优化 性能优化原则 要依靠数据而不是猜测。 要定位最大瓶颈而不是细枝末节 不要过早优化 不要过度优化 性能分析工具 pprof 首页：http://localhost:6060/debug/pprof/
查看CPU go tool pprof -http=:8080 &amp;#34;http://localhost:6060/debug/pprof/profile?second=10&amp;#34; top list Eat web 查看堆内存 go tool pprof -http=:8080 &amp;#34;http:localhost:6060/debug/pprof/heap&amp;#34; 可切换当前/累计 内存/对象数据，查找未使用的内存。
goroutine go tool pprof -http=:8080 &amp;#34;http://localhost:6060/debug/pprof/goroutine&amp;#34; 通过graph或火焰图分析。
mutex go tool pprof -http=:8080 &amp;#34;http://localhost:6060/debug/pprof/mutex&amp;#34; block ThreadCreate pprof采样原理 CPU 在程序启动时，向操作系统加入一个10ms定时器。 到达时间后，记录一次CPU信息。 每100ms将记录写入输出流。</description></item><item><title>生成唯一ID的方式</title><link>https://magiconline.github.io/post/%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80id%E7%9A%84%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 09 May 2022 14:37:37 +0800</pubDate><guid>https://magiconline.github.io/post/%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80id%E7%9A%84%E6%96%B9%E5%BC%8F/</guid><description>ID生成的要求 全局唯一：
递增：数据库中的索引需要主键有序才能保证高性能
有序：满足事务、增量消息、排序等特殊需求
安全：不能为简单的连续ID，防止爬虫等
包含时间信息：可以根据ID提取时间信息
UUID 包含32个16进制数字，分为8-4-4-4-12的形式，性能高。 问题是UUID为无序数据，数据库插入性能差，作为主键过长。
数据库自增主键 基于redis INCR原子操作 雪花算法 按照时间有序生成，结果是64bit的整数。
结构：1bit符号位（一般为正数、固定为0），41bit时间戳（毫秒），10bit工作进程位（共1024个节点），12bit序列号（一个节点一毫秒内最多产生4096个ID）。
生成的ID按时间趋势递增。</description></item><item><title>Go语言上手-工程实践笔记</title><link>https://magiconline.github.io/post/go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 08 May 2022 16:56:52 +0800</pubDate><guid>https://magiconline.github.io/post/go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</guid><description>CSP(Communicating Sequential Processes, 通信顺序进程) 通过通信共享内存
ch := make(chan int, 10) ch &amp;lt;- 1 &amp;lt;-ch 通过共享内存实现通信 lock := sync.Mutex lock.Lock() lock.Unlock()</description></item></channel></rss>